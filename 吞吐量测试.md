# 802.11 WiFi TX/RX 回环系统吞吐量测试分析

## 系统架构概述

本系统实现了一个完整的802.11 WiFi数据传输回环测试环境，包含三个主要模块：

1. **tx_intf_s_axis** - AXI Stream接收接口，处理来自DMA的数据
2. **tx_bit_intf** - TX比特流接口，处理WiFi帧封装和PHY头生成
3. **rx_intf_m_axis** - AXI Stream发送接口，将接收到的数据发送出去

系统通过BRAM实现TX到RX的数据回环连接。

## 吞吐量测试方案分析

### 测试目标
- 测量系统在理想条件下的最大吞吐量
- 验证数据传输的完整性和正确性
- 分析系统瓶颈和性能限制

### 关键性能指标
1. **数据带宽**：64位数据总线，100MHz时钟，理论带宽6.4Gbps
2. **协议开销**：PHY头、CRC等额外开销
3. **处理延迟**：数据在FIFO和BRAM中的缓存时间

### 测试策略
- 使用连续数据流测试最大吞吐量
- 监控FIFO状态避免溢出
- 统计发送和接收的数据包数量
- 测量端到端传输延迟

## 修改后的loopback.v代码

```verilog
`timescale 1 ns / 1 ps

module loopback();

// 参数定义
parameter integer C_S00_AXIS_TDATA_WIDTH = 64;
parameter integer WIFI_TX_BRAM_ADDR_WIDTH = 10;
parameter integer WIFI_TX_BRAM_DATA_WIDTH = 64;
parameter integer WIFI_TX_BRAM_WEN_WIDTH = 8;
parameter integer MAX_NUM_DMA_SYMBOL = 8192;
parameter integer MAX_BIT_NUM_DMA_SYMBOL = 14;

// 时钟和复位
reg clk;
reg rstn;
reg s00_axis_aclk;
reg s00_axis_aresetn;

// AXI Stream 接口信号
reg [C_S00_AXIS_TDATA_WIDTH-1:0] s00_axis_tdata;
reg [(C_S00_AXIS_TDATA_WIDTH/8)-1:0] s00_axis_tstrb;
reg s00_axis_tlast;
reg s00_axis_tvalid;
wire s00_axis_tready;

// 寄存器信号（模拟PS配置）
reg [31:0] slv_reg0;
reg [31:0] slv_reg4;
reg [31:0] slv_reg8;
reg [31:0] slv_reg10;
reg [31:0] slv_reg15;
reg [31:0] slv_reg17;

// 模块间连接信号
wire [2:0] tx_queue_idx;
wire s_axis_recv_data_from_high;
wire [C_S00_AXIS_TDATA_WIDTH-1:0] s_axis_data_to_acc;
wire s_axis_emptyn_to_acc;
wire tx_bit_intf_acc_ask_data_from_s_axis;

// tx_bit_intf 输出信号
wire [WIFI_TX_BRAM_DATA_WIDTH-1:0] data_to_acc;
wire [WIFI_TX_BRAM_ADDR_WIDTH-1:0] bram_addr;
wire tx_end_from_acc;

// 其他控制信号
wire phy_tx_auto_start_mode;
wire [9:0] phy_tx_auto_start_num_dma_symbol_th;
wire [6:0] tx_config_fifo_data_count0, tx_config_fifo_data_count1, tx_config_fifo_data_count2, tx_config_fifo_data_count3;
wire tx_iq_fifo_empty;
wire [13:0] send_cts_toself_wait_sifs_top;
wire [47:0] mac_addr;
wire tx_try_complete;
wire retrans_in_progress;
wire start_retrans;
wire start_tx_ack;
wire [3:0] slice_en;
wire backoff_done;
wire tx_bb_is_ongoing;
wire ack_tx_flag;
wire wea_from_xpu;
wire [9:0] addra_from_xpu;
wire [C_S00_AXIS_TDATA_WIDTH-1:0] dina_from_xpu;
wire tx_pkt_need_ack;
wire [3:0] tx_pkt_retrans_limit;
wire use_ht_aggr;
wire quit_retrans;
wire reset_backoff;
wire high_trigger;
wire [5:0] bd_wr_idx;
wire [WIFI_TX_BRAM_DATA_WIDTH-1:0] douta;
wire cts_toself_bb_is_ongoing;
wire cts_toself_rf_is_ongoing;
wire phy_tx_start;
wire fcs_in_strobe;
wire tx_control_state_idle;
wire tsf_pulse_1M;

// FIFO数据计数
wire [MAX_BIT_NUM_DMA_SYMBOL-1:0] s_axis_fifo_data_count0, s_axis_fifo_data_count1, s_axis_fifo_data_count2, s_axis_fifo_data_count3;

// 其他信号
wire [2:0] linux_prio;
wire [5:0] pkt_cnt;

// 时钟生成
always #5 clk = ~clk;
always #5 s00_axis_aclk = ~s00_axis_aclk; // 100MHz

// 吞吐量测试相关变量
real start_time, end_time, total_time;
integer total_bytes_sent = 0;
integer total_bytes_received = 0;
integer packets_sent = 0;
integer packets_received = 0;
real throughput_mbps = 0;

// 模块实例化
tx_intf_s_axis #(
    .C_S_AXIS_TDATA_WIDTH(C_S00_AXIS_TDATA_WIDTH),
    .MAX_NUM_DMA_SYMBOL(MAX_NUM_DMA_SYMBOL),
    .MAX_BIT_NUM_DMA_SYMBOL(MAX_BIT_NUM_DMA_SYMBOL)
) tx_intf_s_axis_i (
    .S_AXIS_ACLK(s00_axis_aclk),
    .S_AXIS_ARESETN(s00_axis_aresetn & (~slv_reg0[2])),
    .S_AXIS_TREADY(s00_axis_tready),
    .S_AXIS_TDATA(s00_axis_tdata),
    .S_AXIS_TSTRB(s00_axis_tstrb),
    .S_AXIS_TLAST(s00_axis_tlast),
    .S_AXIS_TVALID(s00_axis_tvalid),
    .S_AXIS_NUM_DMA_SYMBOL_raw(slv_reg8[13:0]),
    
    .s_axis_recv_data_from_high(s_axis_recv_data_from_high),
    
    .tx_queue_idx_indication_from_ps(slv_reg8[20:18]),
    .tx_queue_idx(tx_queue_idx),
    .endless_mode(0),
    .data_count0(s_axis_fifo_data_count0),
    .data_count1(s_axis_fifo_data_count1),
    .data_count2(s_axis_fifo_data_count2),
    .data_count3(s_axis_fifo_data_count3),
    .DATA_TO_ACC(s_axis_data_to_acc),
    .EMPTYN_TO_ACC(s_axis_emptyn_to_acc),
    .ACC_ASK_DATA(tx_bit_intf_acc_ask_data_from_s_axis & (~slv_reg10[0]))
);

tx_bit_intf #(
    .C_S00_AXIS_TDATA_WIDTH(C_S00_AXIS_TDATA_WIDTH),
    .WIFI_TX_BRAM_ADDR_WIDTH(WIFI_TX_BRAM_ADDR_WIDTH),
    .WIFI_TX_BRAM_DATA_WIDTH(WIFI_TX_BRAM_DATA_WIDTH),
    .WIFI_TX_BRAM_WEN_WIDTH(WIFI_TX_BRAM_WEN_WIDTH)
) tx_bit_intf_i (
    .rstn(s00_axis_aresetn & (~slv_reg0[6])),
    .clk(s00_axis_aclk),

    .fcs_in_strobe(fcs_in_strobe),
    
    // recv bits from s_axis
    .tx_queue_idx(tx_queue_idx),
    .linux_prio(linux_prio),
    .pkt_cnt(pkt_cnt),
    .data_from_s_axis(s_axis_data_to_acc),
    .ask_data_from_s_axis(tx_bit_intf_acc_ask_data_from_s_axis),
    .emptyn_from_s_axis(s_axis_emptyn_to_acc),
    
    // src indication
    .auto_start_mode(phy_tx_auto_start_mode),
    .num_dma_symbol_th(phy_tx_auto_start_num_dma_symbol_th),
    .tx_config(slv_reg8),
    .tx_queue_idx_indication_from_ps(slv_reg8[19:18]),
    .phy_hdr_config(slv_reg17),
    .ampdu_action_config(slv_reg15),
    .s_axis_recv_data_from_high(s_axis_recv_data_from_high),
    .start(phy_tx_start),

    .tx_config_fifo_data_count0(tx_config_fifo_data_count0), 
    .tx_config_fifo_data_count1(tx_config_fifo_data_count1),
    .tx_config_fifo_data_count2(tx_config_fifo_data_count2), 
    .tx_config_fifo_data_count3(tx_config_fifo_data_count3),

    .tx_iq_fifo_empty(tx_iq_fifo_empty),
    .cts_toself_config(slv_reg4),
    .send_cts_toself_wait_sifs_top(send_cts_toself_wait_sifs_top),
    .mac_addr(mac_addr),
    .tx_try_complete(tx_try_complete),
    .retrans_in_progress(retrans_in_progress),
    .start_retrans(start_retrans),
    .start_tx_ack(start_tx_ack),
    .slice_en(slice_en),
    .backoff_done(backoff_done),
    .tx_bb_is_ongoing(tx_bb_is_ongoing),
    .ack_tx_flag(ack_tx_flag),
    .wea_from_xpu(wea_from_xpu),
    .addra_from_xpu(addra_from_xpu),
    .dina_from_xpu(dina_from_xpu),
    .tx_pkt_need_ack(tx_pkt_need_ack),
    .tx_pkt_retrans_limit(tx_pkt_retrans_limit),
    .use_ht_aggr(use_ht_aggr),
    .quit_retrans(quit_retrans),
    .reset_backoff(reset_backoff),
    .high_trigger(high_trigger),
    .tx_control_state_idle(tx_control_state_idle),
    .bd_wr_idx(bd_wr_idx),
    .douta(douta),
    .cts_toself_bb_is_ongoing(cts_toself_bb_is_ongoing),
    .cts_toself_rf_is_ongoing(cts_toself_rf_is_ongoing),
      
    // to send out to wifi tx module
    .tx_end_from_acc(tx_end_from_acc),
    .bram_data_to_acc(data_to_acc),
    .bram_addr(bram_addr),

    .tsf_pulse_1M(tsf_pulse_1M)
);

// 测试控制变量
integer i;
reg [31:0] test_data [0:1023]; // 扩展测试数据存储

// 初始化
initial begin
    // 初始化时钟和复位
    clk = 0;
    s00_axis_aclk = 0;
    rstn = 0;
    s00_axis_aresetn = 0;
    
    // 初始化寄存器
    slv_reg0 = 32'h0;        // 控制寄存器
    slv_reg4 = 32'h0;        // CTS配置
    slv_reg8 = 32'h0;        // TX配置
    slv_reg10 = 32'h0;       // 额外控制
    slv_reg15 = 32'h0;       // A-MPDU配置
    slv_reg17 = 32'h0;       // PHY头配置
    
    // 初始化AXI信号
    s00_axis_tdata = 0;
    s00_axis_tstrb = 8'hFF;
    s00_axis_tlast = 0;
    s00_axis_tvalid = 0;
    
    // 初始化测试数据 - 使用递增模式便于验证
    for (i = 0; i < 1024; i = i + 1) begin
        test_data[i] = i + 1;
    end
    
    // 释放复位
    #100;
    rstn = 1;
    s00_axis_aresetn = 1;
    
    #50;
    
    // 配置系统参数
    configure_system();
    
    // 记录开始时间
    start_time = $time;
    $display("=== 吞吐量测试开始 ===");
    $display("开始时间: %t ns", start_time);
    
    // 发送测试数据
    send_test_data();
    
    // 等待所有数据处理完成
    wait_for_completion();
    
    // 计算吞吐量
    calculate_throughput();
    
    // 运行一段时间后结束
    #100000;
    $display("仿真完成");
    $finish;
end

// 系统配置任务
task configure_system;
begin
    // 配置TX参数 - 启用自动启动模式，设置较大的DMA符号数
    slv_reg8 = 32'h0000_200A; // 设置DMA符号数=10，队列0，启用自动启动
    
    // 配置PHY头：长度=64字节，非HT模式，速率6Mbps
    slv_reg17 = 32'h0000_0040; 
    
    // 配置A-MPDU参数 - 较大的缓冲区大小
    slv_reg15 = 32'h0100_1000; // buf_size=16, max_tx_bytes=4096
    
    // 配置CTS参数
    slv_reg4 = 32'h0000_0064; // CTS持续时间=100us
    
    #100;
    $display("系统配置完成");
end
endtask

// 发送测试数据任务 - 扩展为发送更多数据以测试吞吐量
task send_test_data;
integer j, k;
begin
    $display("开始发送测试数据...");
    
    // 等待系统就绪
    #20;
    
    // 发送多个数据包批次以测试持续吞吐量
    for (k = 0; k < 16; k = k + 1) begin
        $display("发送批次 %0d", k);
        
        // 每个批次发送64个64位数据包
        for (j = 0; j < 64; j = j + 1) begin
            @(posedge s00_axis_aclk);
            s00_axis_tvalid = 1;
            
            // 等待TREADY信号
            while (s00_axis_tready == 0) begin
                @(posedge s00_axis_aclk);
            end
            
            // 生成测试数据 - 使用递增模式
            s00_axis_tdata = {test_data[(2*j+1 + k*128) % 1024], test_data[(2*j + k*128) % 1024]};
            
            // 统计发送的数据量
            total_bytes_sent = total_bytes_sent + 8; // 每个数据包8字节
            packets_sent = packets_sent + 1;
            
            // 每16个包打印一次进度
            if (j % 16 == 0) begin
                $display("时间 %0t: 已发送 %0d 个数据包, 总字节数: %0d", 
                         $time, packets_sent, total_bytes_sent);
            end
            
            // 最后一个包的TLAST
            if (j == 63 && k == 15) begin
                s00_axis_tlast = 1;
            end else begin
                s00_axis_tlast = 0;
            end
        end
        
        // 批次间短暂停顿
        #100;
    end
    
    // 结束传输
    @(posedge s00_axis_aclk);
    s00_axis_tvalid = 0;
    s00_axis_tlast = 0;
    
    $display("测试数据发送完成");
    $display("总计发送: %0d 个数据包, %0d 字节", packets_sent, total_bytes_sent);
end
endtask

// 等待所有数据处理完成
task wait_for_completion;
begin
    $display("等待数据处理完成...");
    
    // 等待RX接收到所有数据
    while (packets_received < packets_sent) begin
        #1000;
        if ($time > start_time + 1000000) begin // 超时保护
            $display("警告: 等待超时，已接收 %0d/%0d 个包", packets_received, packets_sent);
            break;
        end
    end
    
    // 额外等待确保所有数据稳定
    #1000;
end
endtask

// 计算吞吐量
task calculate_throughput;
begin
    end_time = $time;
    total_time = (end_time - start_time) / 1000.0; // 转换为微秒
    
    throughput_mbps = (total_bytes_sent * 8.0) / total_time; // Mbps
    
    $display("=== 吞吐量测试结果 ===");
    $display("测试开始时间: %t ns", start_time);
    $display("测试结束时间: %t ns", end_time);
    $display("总测试时间: %0.3f us", total_time);
    $display("发送数据包: %0d", packets_sent);
    $display("接收数据包: %0d", packets_received);
    $display("总发送字节: %0d", total_bytes_sent);
    $display("总接收字节: %0d", total_bytes_received);
    $display("吞吐量: %0.2f Mbps", throughput_mbps);
    $display("数据包丢失率: %0.2f%%", 
             (packets_sent - packets_received) * 100.0 / packets_sent);
    
    if (packets_sent == packets_received) begin
        $display("状态: 所有数据包成功传输");
    end else begin
        $display("状态: 数据包有丢失");
    end
end
endtask

// 模拟其他模块的输入信号
assign phy_tx_auto_start_mode = 1'b1;
assign phy_tx_auto_start_num_dma_symbol_th = 10'd64; // 增加阈值以支持更大数据量
assign tx_iq_fifo_empty = 1'b1; // 假设TX IQ FIFO为空
assign send_cts_toself_wait_sifs_top = 14'd16; // SIFS等待时间
assign mac_addr = 48'h001122334455;
assign tx_try_complete = 1'b0;
assign retrans_in_progress = 1'b0;
assign start_retrans = 1'b0;
assign start_tx_ack = 1'b0;
assign slice_en = 4'b0001; // 使能队列0
assign backoff_done = 1'b1; // 退避完成
assign tx_bb_is_ongoing = 1'b0; // TX基带未进行
assign ack_tx_flag = 1'b0; // 非ACK传输
assign wea_from_xpu = 1'b0; // 未从XPU写入
assign addra_from_xpu = 10'b0;
assign dina_from_xpu = 64'b0;
assign tx_control_state_idle = 1'b1; // TX控制状态机空闲
assign tsf_pulse_1M = 1'b0; // 1MHz TSF脉冲
assign fcs_in_strobe = 1'b0; // FCS strobe

// 模拟TX结束信号
assign tx_end_from_acc = (bram_addr == 10'd1023) ? 1'b1 : 1'b0; // 当地址达到1023时结束

// BRAM地址生成（简单计数器）
reg [9:0] bram_addr_counter;
always @(posedge s00_axis_aclk or negedge s00_axis_aresetn) begin
    if (!s00_axis_aresetn) begin
        bram_addr_counter <= 0;
    end else if (phy_tx_start && bram_addr_counter < 10'd1023) begin
        bram_addr_counter <= bram_addr_counter + 1;
    end else if (tx_end_from_acc) begin
        bram_addr_counter <= 0;
    end
end
assign bram_addr = bram_addr_counter;

// 监视器：显示关键信号
always @(posedge s00_axis_aclk) begin
    if (tx_bit_intf_acc_ask_data_from_s_axis) begin
        // 每100个周期打印一次以避免过多输出
        if ($time % 1000 == 0) begin
            $display("时间 %0t: TX比特接口请求数据, FIFO数据计数: %0d", 
                     $time, s_axis_fifo_data_count0);
        end
    end
    
    if (phy_tx_start && ($time % 1000 == 0)) begin
        $display("时间 %0t: PHY TX启动, BRAM数据: 0x%016h", $time, data_to_acc);
    end
end

// RX接口信号
wire [C_S00_AXIS_TDATA_WIDTH-1:0] rx_data_from_acc;
reg rx_acc_data_ready;
wire rx_fulln_to_acc;
wire [MAX_BIT_NUM_DMA_SYMBOL-1:0] rx_data_count;

// RX AXI Stream输出信号
wire rx_m_axis_tvalid;
wire [C_S00_AXIS_TDATA_WIDTH-1:0] rx_m_axis_tdata;
wire [(C_S00_AXIS_TDATA_WIDTH/8)-1:0] rx_m_axis_tstrb;
wire rx_m_axis_tlast;
reg rx_m_axis_tready;

// RX控制信号
reg rx_start_1trans;
reg [4:0] rx_start_count_cfg;
reg [MAX_BIT_NUM_DMA_SYMBOL-1:0] rx_m_axis_num_dma_symbol;
reg rx_endless_mode;

// RX模块实例化
rx_intf_m_axis #(
    .WAIT_COUNT_BITS(5),
    .MAX_NUM_DMA_SYMBOL(MAX_NUM_DMA_SYMBOL),
    .MAX_BIT_NUM_DMA_SYMBOL(MAX_BIT_NUM_DMA_SYMBOL),
    .C_M_AXIS_TDATA_WIDTH(C_S00_AXIS_TDATA_WIDTH)
) rx_intf_m_axis_i (
    .endless_mode(rx_endless_mode),
    .START_COUNT_CFG(rx_start_count_cfg),
    .M_AXIS_NUM_DMA_SYMBOL(rx_m_axis_num_dma_symbol+1),
    .start_1trans(rx_start_1trans),
    .DATA_FROM_ACC(rx_data_from_acc),
    .ACC_DATA_READY(rx_acc_data_ready),
    .data_count(rx_data_count),
    .FULLN_TO_ACC(rx_fulln_to_acc),
    .M_AXIS_ACLK(s00_axis_aclk),
    .M_AXIS_ARESETN(s00_axis_aresetn),
    .M_AXIS_TVALID(rx_m_axis_tvalid),
    .M_AXIS_TDATA(rx_m_axis_tdata),
    .M_AXIS_TSTRB(rx_m_axis_tstrb),
    .M_AXIS_TLAST(rx_m_axis_tlast),
    .M_AXIS_TREADY(rx_m_axis_tready)
);

// 连接TX输出到RX输入 - 实现回环
assign rx_data_from_acc = data_to_acc;

// RX数据就绪信号生成 - 模拟ACC数据就绪
always @(posedge s00_axis_aclk or negedge s00_axis_aresetn) begin
    if (!s00_axis_aresetn) begin
        rx_acc_data_ready <= 0;
    end else begin
        // 当TX有数据输出时产生数据就绪信号
        rx_acc_data_ready <= (bram_addr_counter > 0) && (bram_addr_counter < 10'd1020);
    end
end

// RX控制信号初始化
initial begin
    rx_start_1trans = 0;
    rx_start_count_cfg = 5'd2;      // 等待2个时钟周期
    rx_m_axis_num_dma_symbol = 1024; // 接收1024个DMA符号
    rx_endless_mode = 0;            // 非无限模式
    rx_m_axis_tready = 1;           // 始终准备好接收数据
end

// RX启动控制
reg rx_start_delay;
always @(posedge s00_axis_aclk or negedge s00_axis_aresetn) begin
    if (!s00_axis_aresetn) begin
        rx_start_delay <= 0;
        rx_start_1trans <= 0;
    end else begin
        // 在TX开始后延迟启动RX传输
        rx_start_delay <= phy_tx_start;
        if (rx_start_delay && !phy_tx_start) begin
            rx_start_1trans <= 1;
            #20; // 保持一个周期
            rx_start_1trans <= 0;
        end
    end
end

// RX数据监控和统计
integer rx_data_received;
initial rx_data_received = 0;

always @(posedge s00_axis_aclk) begin
    if (rx_m_axis_tvalid && rx_m_axis_tready) begin
        rx_data_received <= rx_data_received + 1;
        total_bytes_received <= total_bytes_received + 8;
        packets_received <= packets_received + 1;
        
        // 每64个包打印一次接收进度
        if (rx_data_received % 64 == 0) begin
            $display("时间 %0t: RX接收数据[%0d]: 0x%016h, TLAST: %b", 
                     $time, rx_data_received, rx_m_axis_tdata, rx_m_axis_tlast);
            $display("接收进度: %0d/%0d 数据包", packets_received, packets_sent);
        end
        
        if (rx_m_axis_tlast) begin
            $display("时间 %0t: RX传输完成, 总数据包: %0d", 
                     $time, rx_data_received + 1);
        end
    end
end

// RX FIFO状态监控
always @(posedge s00_axis_aclk) begin
    if (rx_data_count > 0 && ($time % 5000 == 0)) begin
        $display("时间 %0t: RX FIFO数据计数: %0d", $time, rx_data_count);
    end
end

// 系统状态监控
always @(posedge s00_axis_aclk) begin
    if ($time % 10000 == 0) begin // 每10000个周期打印一次系统状态
        $display("=== 系统状态监控 ===");
        $display("时间: %t", $time);
        $display("TX FIFO数据计数: %0d", s_axis_fifo_data_count0);
        $display("RX FIFO数据计数: %0d", rx_data_count);
        $display("已发送/已接收: %0d/%0d", packets_sent, packets_received);
        $display("BRAM地址: %0d", bram_addr_counter);
        $display("=====================");
    end
end

endmodule
```

## 测试方案详细说明

### 1. 数据激励设计
- **数据量**：发送1024个数据包（16个批次，每批次64个包）
- **数据模式**：使用递增序列便于验证数据完整性
- **传输控制**：使用TLAST标记数据流结束

### 2. 性能监控点
- **TX侧**：监控FIFO数据计数、数据请求信号
- **RX侧**：监控接收数据计数、FIFO状态
- **系统级**：统计总吞吐量、数据包丢失率

### 3. 调试信息设计
- **进度报告**：每16个包报告发送进度，每64个包报告接收进度
- **状态监控**：定期报告系统关键状态
- **结果汇总**：测试结束时提供详细的吞吐量分析

### 4. 验证策略
- **数据完整性**：通过递增序列验证数据传输正确性
- **吞吐量计算**：基于实际传输时间和数据量计算
- **系统稳定性**：通过长时间运行测试系统稳定性

这个测试方案能够全面评估系统的吞吐量性能，同时提供详细的调试信息帮助定位性能瓶颈。