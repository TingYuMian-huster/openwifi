# 提高802.11 WiFi回环系统吞吐量的优化方案

## 系统瓶颈分析

### 1. 数据路径瓶颈
- **AXI Stream接口**：64位@100MHz，理论带宽6.4Gbps
- **FIFO深度和延迟**：可能成为数据流瓶颈
- **状态机处理延迟**：PHY头生成、CRC计算等

### 2. 协议开销
- **PHY头开销**：L-SIG、HT-SIG等字段
- **CRC计算延迟**：影响数据处理流水线
- **帧间间隔**：SIFS、DIFS等

## 具体优化修改方案

### 1. 增加数据位宽和时钟频率

```verilog
// 在loopback.v中修改参数
parameter integer C_S00_AXIS_TDATA_WIDTH = 128; // 从64位增加到128位
parameter integer WIFI_TX_BRAM_DATA_WIDTH = 128; // 相应增加BRAM数据宽度

// 修改时钟生成 - 提高到200MHz
always #2.5 clk = ~clk; // 200MHz时钟
always #2.5 s00_axis_aclk = ~s00_axis_aclk;
```

### 2. 优化FIFO配置

```verilog
// 增加FIFO深度减少阻塞
parameter integer MAX_NUM_DMA_SYMBOL = 16384; // 从8192增加到16384

// 在系统配置中调整FIFO阈值
task configure_system;
begin
    // 优化FIFO阈值，减少空转
    slv_reg8 = 32'h0000_400A; // 增加DMA符号数，降低启动阈值
    slv_reg15 = 32'h0200_2000; // 增加A-MPDU缓冲区大小
end
endtask
```

### 3. 流水线优化

```verilog
// 在tx_bit_intf实例化前添加流水线寄存器，减少关键路径延迟
reg [C_S00_AXIS_TDATA_WIDTH-1:0] s_axis_data_to_acc_reg;
reg s_axis_emptyn_to_acc_reg;
reg tx_bit_intf_acc_ask_data_from_s_axis_reg;

always @(posedge s00_axis_aclk) begin
    if (s00_axis_aresetn) begin
        s_axis_data_to_acc_reg <= s_axis_data_to_acc;
        s_axis_emptyn_to_acc_reg <= s_axis_emptyn_to_acc;
        tx_bit_intf_acc_ask_data_from_s_axis_reg <= tx_bit_intf_acc_ask_data_from_s_axis;
    end
end

// 修改tx_bit_intf连接使用流水线版本
.data_from_s_axis(s_axis_data_to_acc_reg),
.emptyn_from_s_axis(s_axis_emptyn_to_acc_reg),
.ACC_ASK_DATA(tx_bit_intf_acc_ask_data_from_s_axis_reg & (~slv_reg10[0]))
```

### 4. 批量传输优化

```verilog
// 修改发送任务，使用更大的数据包和连续传输
task send_test_data;
integer j, k;
begin
    $display("开始高吞吐量测试数据发送...");
    
    // 使用更大的数据包和更少的批次间隔
    for (k = 0; k < 8; k = k + 1) begin  // 减少批次数量
        $display("发送高吞吐量批次 %0d", k);
        
        // 每个批次发送256个数据包（增加4倍）
        for (j = 0; j < 256; j = j + 1) begin
            @(posedge s00_axis_aclk);
            s00_axis_tvalid = 1;
            
            // 优化TREADY等待逻辑
            if (s00_axis_tready == 0) begin
                // 非阻塞等待，避免死锁
                repeat(2) @(posedge s00_axis_aclk);
            end
            
            // 使用预计算的数据模式，减少实时计算开销
            s00_axis_tdata = {32'hA5A5A5A5 + j + k*256, 32'h5A5A5A5A + j + k*256};
            
            total_bytes_sent = total_bytes_sent + 16; // 128位=16字节
            packets_sent = packets_sent + 1;
            
            // 减少打印频率，避免仿真开销
            if (j % 64 == 0) begin
                $display("时间 %0t: 高速发送进度 - 批次%d: %d/%d", 
                         $time, k, j, 256);
            end
            
            // 只在最后一个包的最后一个批次设置TLAST
            if (j == 255 && k == 7) begin
                s00_axis_tlast = 1;
            end else begin
                s00_axis_tlast = 0;
            end
        end
        
        // 减少批次间间隔
        #20; // 从100减少到20
    end
    
    @(posedge s00_axis_aclk);
    s00_axis_tvalid = 0;
    s00_axis_tlast = 0;
    
    $display("高吞吐量测试数据发送完成");
end
endtask
```

### 5. 协议参数优化

```verilog
// 优化WiFi协议参数减少开销
task configure_system;
begin
    // 使用HT模式提高数据速率
    slv_reg17 = 32'h8000_0800; // 启用HT模式，MCS7 (65Mbps)
    
    // 配置更激进的A-MPDU参数
    slv_reg15 = 32'h0400_4000; // buf_size=64, max_tx_bytes=16384
    
    // 禁用CTS保护减少开销（在干净环境中）
    slv_reg4 = 32'h0000_0000; // 禁用CTS
    
    // 配置短保护间隔
    slv_reg17 = slv_reg17 | 32'h0000_4000; // 启用短GI
    
    $display("高性能系统配置完成 - HT模式启用");
end
endtask
```

### 6. 内存访问优化

```verilog
// 优化BRAM访问模式
reg [9:0] bram_addr_counter;
reg bram_access_optimized;

always @(posedge s00_axis_aclk or negedge s00_axis_aresetn) begin
    if (!s00_axis_aresetn) begin
        bram_addr_counter <= 0;
        bram_access_optimized <= 0;
    end else begin
        // 预取优化：提前增加地址计数器
        if (phy_tx_start && !bram_access_optimized) begin
            bram_addr_counter <= 1; // 预取下一个地址
            bram_access_optimized <= 1;
        end else if (bram_access_optimized && bram_addr_counter < 10'd1023) begin
            bram_addr_counter <= bram_addr_counter + 1;
        end else if (tx_end_from_acc) begin
            bram_addr_counter <= 0;
            bram_access_optimized <= 0;
        end
    end
end

// 使用Block RAM的true dual port模式提高并发访问
xpm_memory_tdpram #(
    .MEMORY_SIZE(8*16384),  // 增加BRAM容量
    .WRITE_DATA_WIDTH_A(128),
    .READ_DATA_WIDTH_A(128),
    .WRITE_DATA_WIDTH_B(128), 
    .READ_DATA_WIDTH_B(128),
    // 其他参数保持不变...
)
```

### 7. 状态机优化

```verilog
// 在tx_bit_intf包装层添加状态机优化
// 注意：这需要修改tx_bit_intf模块，这里展示包装思路

// 快速路径优化：对于连续数据包跳过某些状态检查
wire fast_path_enable = (pkt_cnt > 0) && (high_tx_ctl_state == DO_TX);

// 预计算优化：提前计算下一个数据包参数
reg [12:0] next_len_pkt_sym;
always @(posedge s00_axis_aclk) begin
    if (high_tx_ctl_state == CHECK_AGGR && !div_busy) begin
        next_len_pkt_sym <= len_psdu[12:3] + (|len_psdu[2:0] ? 1 : 0);
    end
end
```

### 8. 监控和调试优化

```verilog
// 添加性能计数器
reg [31:0] cycle_counter;
reg [31:0] data_valid_cycles;
real utilization;

always @(posedge s00_axis_aclk) begin
    if (s00_axis_aresetn) begin
        cycle_counter <= cycle_counter + 1;
        if (s00_axis_tvalid && s00_axis_tready) begin
            data_valid_cycles <= data_valid_cycles + 1;
        end
    end
end

// 计算链路利用率
always @(posedge s00_axis_aclk) begin
    if (cycle_counter > 0) begin
        utilization = (data_valid_cycles * 100.0) / cycle_counter;
    end
end

// 在吞吐量计算中包含利用率信息
task calculate_throughput;
begin
    // 原有计算...
    $display("链路利用率: %0.2f%%", utilization);
    $display("理论最大吞吐量: %0.2f Mbps", 128 * 200); // 128位 * 200MHz
    $display("实际效率: %0.2f%%", (throughput_mbps * 100.0) / (128 * 200));
end
endtask
```

## 系统级优化建议

### 1. 架构优化
- **增加并行处理单元**：多个队列并行处理
- **实现数据预取**：提前加载下一帧数据
- **缓存优化**：增加数据局部性

### 2. 协议栈优化
- **帧聚合**：使用A-MPDU聚合多个帧
- **块确认**：减少ACK开销
- **动态速率适配**：根据信道质量调整速率

### 3. 资源优化
- **BRAM分区**：为不同队列分配独立BRAM
- **FIFO大小自适应**：根据流量动态调整FIFO深度
- **电源管理**：在低流量时降低功耗

## 预期性能提升

通过这些优化，预期吞吐量可以从原始的~200-300Mbps提升到：

- **中等优化**：500-800Mbps（2-3倍提升）
- **深度优化**：1-1.5Gbps（4-6倍提升）
- **极限优化**：接近2Gbps（受限于200MHz时钟和128位总线）

关键优化按效果排序：
1. 增加数据位宽和时钟频率（最大影响）
2. 协议参数优化（HT模式、短GI等）
3. 流水线和预取优化
4. FIFO和内存优化
5. 批量传输优化

这些优化需要在仿真中逐步验证，确保功能正确性和稳定性。


# 802.11 WiFi回环系统吞吐量优化方案（模块级修改）

## 核心优化思路

### 1. 数据路径并行化
### 2. 协议处理流水线化  
### 3. 内存访问优化
### 4. 状态机重构

## 具体模块修改方案

## 1. tx_intf_s_axis.v 优化修改

```verilog
`timescale 1 ns / 1 ps

`include "tx_intf_pre_def.v"

`ifdef TX_INTF_ENABLE_DBG
`define DEBUG_PREFIX (*mark_debug="true",DONT_TOUCH="TRUE"*)
`else
`define DEBUG_PREFIX
`endif

module tx_intf_s_axis #
(
    parameter integer MAX_NUM_DMA_SYMBOL = 16384,  // 增加FIFO深度
    parameter integer MAX_BIT_NUM_DMA_SYMBOL = 15, // 对应增加地址位宽
    parameter integer C_S_AXIS_TDATA_WIDTH = 128   // 增加数据位宽
)
(
    // ... 端口定义保持不变 ...
    
    // 添加性能监控信号
    output wire [3:0] fifo_almost_full,
    output wire [3:0] fifo_almost_empty
);
    // 原有代码...

    // 修改FIFO配置为更大深度和更优性能
    localparam integer bit_num  = clogb2(MAX_NUM_DMA_SYMBOL);

    // 添加流水线寄存器减少关键路径
    `DEBUG_PREFIX reg [C_S_AXIS_TDATA_WIDTH-1 : 0] S_AXIS_TDATA_reg;
    `DEBUG_PREFIX reg S_AXIS_TVALID_reg;
    `DEBUG_PREFIX reg S_AXIS_TLAST_reg;
    
    always @(posedge S_AXIS_ACLK) begin
        if (S_AXIS_ARESETN) begin
            S_AXIS_TDATA_reg <= S_AXIS_TDATA;
            S_AXIS_TVALID_reg <= S_AXIS_TVALID;
            S_AXIS_TLAST_reg <= S_AXIS_TLAST;
        end
    end

    // 优化FIFO写使能生成逻辑 - 减少组合逻辑延迟
    reg [3:0] fifo_wren_reg;
    always @(posedge S_AXIS_ACLK) begin
        if (!S_AXIS_ARESETN) begin
            fifo_wren_reg <= 4'b0000;
        end else begin
            fifo_wren_reg <= {4{S_AXIS_TVALID_reg}} & 
                            (tx_queue_idx_indication_from_ps[1] ? 
                             (tx_queue_idx_indication_from_ps[0] ? 4'b1000 : 4'b0100) :
                             (tx_queue_idx_indication_from_ps[0] ? 4'b0010 : 4'b0001));
        end
    end

    assign fifo_wren0 = fifo_wren_reg[0] && axis_tready0;
    assign fifo_wren1 = fifo_wren_reg[1] && axis_tready1; 
    assign fifo_wren2 = fifo_wren_reg[2] && axis_tready2;
    assign fifo_wren3 = fifo_wren_reg[3] && axis_tready3;

    // 优化TREADY生成逻辑 - 提前计算
    wire [3:0] fifo_not_full = {~FULL3, ~FULL2, ~FULL1, ~FULL0};
    wire state_ready = (mst_exec_state == WRITE_FIFO);
    wire count_ready = (write_pointer <= S_AXIS_NUM_DMA_SYMBOL || endless_mode);
    
    assign axis_tready0 = state_ready && count_ready && fifo_not_full[0];
    assign axis_tready1 = state_ready && count_ready && fifo_not_full[1];
    assign axis_tready2 = state_ready && count_ready && fifo_not_full[2];
    assign axis_tready3 = state_ready && count_ready && fifo_not_full[3];

    // 优化写指针逻辑 - 使用预加器
    reg [bit_num-1:0] write_pointer_next;
    always @* begin
        if (fifo_wren0||fifo_wren1||fifo_wren2||fifo_wren3)
            write_pointer_next = write_pointer + 1;
        else
            write_pointer_next = write_pointer;
    end

    always@(posedge S_AXIS_ACLK) begin
      if ((!S_AXIS_ARESETN) || (writes_done == 1'b1)) begin
          write_pointer <= 0;
          writes_done <= 1'b0;
      end else if (write_pointer <= S_AXIS_NUM_DMA_SYMBOL || (endless_mode==1)) begin
          write_pointer <= write_pointer_next;
          if ((write_pointer_next == S_AXIS_NUM_DMA_SYMBOL && (endless_mode==0)) || S_AXIS_TLAST_reg) begin
              writes_done <= 1'b1;
          end
      end  
    end

    // 使用更高效的FIFO配置
    xpm_fifo_sync #(
        .DOUT_RESET_VALUE("0"),
        .ECC_MODE("no_ecc"),
        .FIFO_MEMORY_TYPE("block"),           // 使用Block RAM提高性能
        .FIFO_READ_LATENCY(1),               // 稍微增加延迟换取更高频率
        .FIFO_WRITE_DEPTH(MAX_NUM_DMA_SYMBOL),
        .FULL_RESET_VALUE(0),
        .PROG_EMPTY_THRESH(32),              // 调整阈值
        .PROG_FULL_THRESH(MAX_NUM_DMA_SYMBOL-32),
        .RD_DATA_COUNT_WIDTH(bit_num),
        .READ_DATA_WIDTH(C_S_AXIS_TDATA_WIDTH),
        .READ_MODE("fwft"),
        .USE_ADV_FEATURES("1704"),           // 启用almost_full/almost_empty
        .WAKEUP_TIME(0),
        .WRITE_DATA_WIDTH(C_S_AXIS_TDATA_WIDTH),
        .WR_DATA_COUNT_WIDTH(bit_num)
    ) fifo128_i0 (
        .almost_empty(fifo_almost_empty[0]),
        .almost_full(fifo_almost_full[0]),
        // ... 其他端口连接保持不变 ...
    );

    // 其他三个FIFO实例类似修改...

endmodule
```

## 2. tx_bit_intf.v 深度优化

```verilog
`timescale 1 ns / 1 ps

`include "tx_intf_pre_def.v"

module tx_bit_intf #
(
    parameter integer C_S00_AXIS_TDATA_WIDTH = 128,  // 增加数据位宽
    parameter integer WIFI_TX_BRAM_ADDR_WIDTH = 11,  // 增加地址位宽支持更大内存
    parameter integer WIFI_TX_BRAM_DATA_WIDTH = 128, // 匹配数据位宽
    parameter integer WIFI_TX_BRAM_WEN_WIDTH = 16
)
(
    // ... 端口定义 ...
    
    // 添加性能监控信号
    output wire [3:0] state_timing_metrics,
    output wire data_path_ready
);
    // 状态定义扩展，支持更细粒度流水线
    localparam [3:0]   WAIT_TO_TRIG=                    4'd0,
                       WAIT_CHANCE =                    4'd1,
                       PREPARE_TX_FETCH=                4'd2,
                       PREPARE_TX_JUDGE=                4'd3,
                       DO_CTS_TOSELF_PREP=              4'd4,  // 新增：CTS准备
                       DO_CTS_TOSELF=                   4'd5,
                       WAIT_SIFS =                      4'd6,
                       CHECK_AGGR =                     4'd7,
                       PREP_PHY_HDR_PARALLEL=           4'd8,  // 新增：并行PHY头准备
                       PREP_PHY_HDR =                   4'd9,
                       DO_PHY_HDR =                     4'd10, // 合并PHY头状态
                       DO_TX_PIPELINE=                  4'd11, // 新增：流水线TX
                       DO_TX =                          4'd12,
                       WAIT_TX_COMP =                   4'd13;

    // 添加并行计算单元
    `DEBUG_PREFIX reg [16:0] l_sig_data_parallel;
    `DEBUG_PREFIX reg l_sig_parity_parallel;
    `DEBUG_PREFIX reg [7:0] ht_sig_crc_parallel;
    `DEBUG_PREFIX reg [33:0] ht_sig_data_parallel;
    
    // 添加预计算逻辑
    always @(posedge clk) begin
        if (!rstn) begin
            l_sig_data_parallel <= 0;
            l_sig_parity_parallel <= 0;
        end else begin
            // 并行计算L-SIG，不等待状态机
            l_sig_data_parallel <= {len_legacy, 1'b0, (use_ht_rate == 0 ? rate_legacy : 4'd11)};
            l_sig_parity_parallel <= ^l_sig_data_parallel;
        end
    end

    // 优化状态机 - 添加快速路径
    always @(posedge clk) begin
        if (!rstn) begin
            // 复位逻辑...
        end else begin
            high_tx_ctl_state_old <= high_tx_ctl_state;
            
            case (high_tx_ctl_state)
                // 原有状态...
                
                PREP_PHY_HDR_PARALLEL: begin
                    // 并行执行多个计算任务
                    if(use_ht_rate == 0) begin
                        // Legacy模式快速路径
                        len_legacy <= len_psdu[11:0] + 4;
                        len_legacy_ready <= 1;
                        high_tx_ctl_state <= DO_PHY_HDR;
                    end else begin
                        // HT模式并行计算
                        if(div_busy == 0 && num_data_sym_ready == 0) begin
                            dividend <= 16 + {len_ht[12:0], 3'd0} + 6;
                            divisor <= {7'd0, dbps_ht};
                            div_start <= 1;
                        end
                        
                        if(ht_sig_crc_busy == 0 && ht_sig_crc_ready == 0) begin
                            ht_sig_data <= {2'd0, use_short_gi, 3'd0, use_ht_aggr, 3'b111, len_ht, 1'd0, 3'd0, rate_hw_value};
                            ht_sig_crc_start <= 1;
                        end
                        
                        // 并行计算L-SIG
                        len_legacy <= 3*(4 + num_data_sym[10:0]) - 3;
                        len_legacy_ready <= 1;
                        
                        if(div_valid && ht_sig_crc_valid) begin
                            high_tx_ctl_state <= DO_PHY_HDR;
                        end
                    end
                end
                
                DO_PHY_HDR: begin
                    // 合并PHY头写入状态
                    wea_internal <= 1;
                    
                    if(use_ht_rate == 0) begin
                        // Legacy: 只写L-SIG
                        addra_internal <= 0;
                        dina_internal <= {64'h0, 7'd0, use_ht_rate, 6'd0, l_sig_parity_parallel, l_sig_data_parallel};
                        wr_counter <= 1;
                    end else begin
                        // HT: 一次写入L-SIG和HT-SIG
                        addra_internal <= 0;
                        dina_internal <= {16'd0, 6'd0, ht_sig_crc_reg, ht_sig_data, 
                                         7'd0, use_ht_rate, 6'd0, l_sig_parity_parallel, l_sig_data_parallel};
                        wr_counter <= 2; // 一次写了两行
                    end
                    
                    read_from_s_axis_en <= 1;
                    high_tx_ctl_state <= DO_TX_PIPELINE;
                end
                
                DO_TX_PIPELINE: begin
                    // 流水线化数据传输
                    wea_internal <= wea_high;
                    addra_internal <= wr_counter;
                    dina_internal <= data_from_s_axis;
                    
                    // 预取下一个地址
                    wr_counter <= wea_high ? (wr_counter + 1) : wr_counter;
                    
                    // 智能预读取控制
                    if (wr_counter < (2 + len_pkt_sym - 4)) begin
                        read_from_s_axis_en <= 1;
                    end else if (wr_counter >= (2 + len_pkt_sym - 1)) begin
                        read_from_s_axis_en <= 0;
                    end
                    
                    high_tx_ctl_state <= (tx_end_from_acc ? WAIT_TO_TRIG : DO_TX_PIPELINE);
                end
                
                // 其他状态...
            endcase
        end
    end

    // 优化除法器 - 使用更高性能的实现
    div_int_pipelined #(
        .WIDTH(16),
        .PIPELINE_STAGES(4)  // 增加流水线级数提高频率
    ) div_int_inst (
        .clk(clk),
        .reset(!rstn),
        .start(div_start),
        .busy(div_busy),
        .valid(div_valid),
        .dbz(div_dbz),
        .x(dividend),
        .y(divisor),
        .q(quotient),
        .r(remainder)
    );

    // 优化CRC计算 - 并行化
    ht_sig_crc_calc_parallel ht_sig_crc_calc_inst (
        .clk(clk),
        .reset(!rstn),
        .d(ht_sig_data),
        .start(ht_sig_crc_start),
        .busy(ht_sig_crc_busy),
        .valid(ht_sig_crc_valid),
        .crc(ht_sig_crc)
    );

    // 优化BRAM访问 - 使用True Dual Port RAM提高并发性
    xpm_memory_tdpram # (
        .MEMORY_SIZE(16*16384),  // 增加内存容量
        .MEMORY_PRIMITIVE("ultra"),  // 使用UltraRAM如果可用
        .CLOCKING_MODE("common_clock"),
        .WRITE_DATA_WIDTH_A(128),
        .READ_DATA_WIDTH_A(128),
        .WRITE_DATA_WIDTH_B(128),
        .READ_DATA_WIDTH_B(128),
        .ADDR_WIDTH_A(11),  // 增加地址位宽
        .ADDR_WIDTH_B(11),
        .READ_LATENCY_A(1),
        .READ_LATENCY_B(1),
        .WRITE_MODE_A("read_first"),
        .WRITE_MODE_B("read_first")
    ) xpm_memory_tdpram_inst (
        // 端口连接...
    );

    // 添加数据路径就绪信号
    assign data_path_ready = (high_tx_ctl_state == DO_TX_PIPELINE) && 
                           (wr_counter < (2 + len_pkt_sym - 1)) &&
                           emptyn_from_s_axis;

    // 添加状态时序监控
    reg [15:0] state_timer;
    always @(posedge clk) begin
        if (!rstn) begin
            state_timer <= 0;
        end else if (high_tx_ctl_state != high_tx_ctl_state_old) begin
            state_timer <= 0;
        end else begin
            state_timer <= state_timer + 1;
        end
    end
    
    assign state_timing_metrics = state_timer[15:12];

endmodule
```

## 3. rx_intf_m_axis.v 优化修改

```verilog
`timescale 1 ns / 1 ps

module rx_intf_m_axis #
(
    parameter integer WAIT_COUNT_BITS = 5,
    parameter integer MAX_NUM_DMA_SYMBOL = 16384,  // 增加FIFO深度
    parameter integer MAX_BIT_NUM_DMA_SYMBOL = 15,  // 对应地址位宽
    parameter integer C_M_AXIS_TDATA_WIDTH = 128   // 增加数据位宽
)
(
    // ... 端口定义 ...
    
    // 添加性能监控信号
    output wire fifo_almost_full,
    output wire fifo_almost_empty,
    output wire [1:0] throughput_status
);
    // 原有代码...
    
    // 优化状态机 - 减少状态转换
    localparam [1:0] IDLE = 2'b00,
                    SEND_STREAM   = 2'b01,  // 合并状态
                    SEND_STREAM_FAST = 2'b10; // 新增快速模式

    // 添加预读取逻辑
    reg read_en_early;
    always @(posedge M_AXIS_ACLK) begin
        if (!M_AXIS_ARESETN) begin
            read_en_early <= 0;
        end else begin
            // 提前一个周期使能读取
            read_en_early <= (mst_exec_state == SEND_STREAM) && 
                           (read_pointer < M_AXIS_NUM_DMA_SYMBOL) &&
                           M_AXIS_TREADY;
        end
    end

    // 优化tvalid生成
    reg axis_tvalid_pre;
    always @(posedge M_AXIS_ACLK) begin
        if (!M_AXIS_ARESETN) begin
            axis_tvalid_pre <= 0;
        end else begin
            axis_tvalid_pre <= read_en_early && !EMPTY;
        end
    end

    assign axis_tvalid = axis_tvalid_pre;

    // 优化tlast生成
    reg axis_tlast_pre;
    always @(posedge M_AXIS_ACLK) begin
        if (!M_AXIS_ARESETN) begin
            axis_tlast_pre <= 0;
        end else begin
            axis_tlast_pre <= (read_pointer == M_AXIS_NUM_DMA_SYMBOL) && 
                            tx_en && (endless_mode==0);
        end
    end

    // 添加快速模式状态
    always @(posedge M_AXIS_ACLK) begin
        if (!M_AXIS_ARESETN) begin
            mst_exec_state <= IDLE;
            count <= 0;
        end else begin
            case (mst_exec_state)
                IDLE:
                    if (init_txn_pulse) begin
                        if (START_COUNT_CFG == 0) begin
                            mst_exec_state <= SEND_STREAM_FAST; // 快速路径
                        end else begin
                            mst_exec_state <= INIT_COUNTER;
                        end
                    end
                    
                SEND_STREAM_FAST: // 零延迟快速模式
                    if (tx_done) begin
                        mst_exec_state <= IDLE;
                    end
                    
                // 其他状态...
            endcase
        end
    end

    // 优化FIFO配置
    xpm_fifo_sync #(
        .DOUT_RESET_VALUE("0"),
        .ECC_MODE("no_ecc"),
        .FIFO_MEMORY_TYPE("block"),  // 使用Block RAM
        .FIFO_READ_LATENCY(1),      // 平衡延迟和性能
        .FIFO_WRITE_DEPTH(MAX_NUM_DMA_SYMBOL),
        .FULL_RESET_VALUE(0),
        .PROG_EMPTY_THRESH(64),     // 优化阈值
        .PROG_FULL_THRESH(MAX_NUM_DMA_SYMBOL-64),
        .RD_DATA_COUNT_WIDTH(bit_num),
        .READ_DATA_WIDTH(C_M_AXIS_TDATA_WIDTH),
        .READ_MODE("fwft"),
        .USE_ADV_FEATURES("1704"),  // 启用高级特性
        .WAKEUP_TIME(0),
        .WRITE_DATA_WIDTH(C_M_AXIS_TDATA_WIDTH),
        .WR_DATA_COUNT_WIDTH(bit_num)
    ) xpm_fifo_sync_rx_intf_m_axis (
        .almost_empty(fifo_almost_empty),
        .almost_full(fifo_almost_full),
        // ... 其他端口 ...
    );

    // 添加吞吐量状态指示
    reg [15:0] valid_cycle_counter;
    reg [15:0] total_cycle_counter;
    
    always @(posedge M_AXIS_ACLK) begin
        if (!M_AXIS_ARESETN) begin
            valid_cycle_counter <= 0;
            total_cycle_counter <= 0;
        end else if (mst_exec_state == SEND_STREAM || mst_exec_state == SEND_STREAM_FAST) {
            total_cycle_counter <= total_cycle_counter + 1;
            if (axis_tvalid && M_AXIS_TREADY) begin
                valid_cycle_counter <= valid_cycle_counter + 1;
            end
        end
    end
    
    // 吞吐量状态编码
    assign throughput_status = (valid_cycle_counter > (total_cycle_counter * 3 / 4)) ? 2'b11 :
                              (valid_cycle_counter > (total_cycle_counter * 2 / 4)) ? 2'b10 :
                              (valid_cycle_counter > (total_cycle_counter * 1 / 4)) ? 2'b01 : 2'b00;

endmodule
```

## 4. 新增高性能计算模块

### div_int_pipelined.v - 流水线除法器
```verilog
module div_int_pipelined #(
    parameter WIDTH = 16,
    parameter PIPELINE_STAGES = 4
)(
    input wire clk,
    input wire reset,
    input wire start,
    output wire busy,
    output wire valid,
    output wire dbz,
    input wire [WIDTH-1:0] x,
    input wire [WIDTH-1:0] y,
    output wire [WIDTH-1:0] q,
    output wire [WIDTH-1:0] r
);
    
    // 流水线寄存器
    reg [WIDTH-1:0] x_pipe [0:PIPELINE_STAGES-1];
    reg [WIDTH-1:0] y_pipe [0:PIPELINE_STAGES-1];
    reg [WIDTH-1:0] q_pipe [0:PIPELINE_STAGES-1];
    reg [WIDTH-1:0] r_pipe [0:PIPELINE_STAGES-1];
    reg valid_pipe [0:PIPELINE_STAGES-1];
    
    // 非恢复除法算法流水线实现
    genvar i;
    generate
        for (i = 0; i < PIPELINE_STAGES; i = i + 1) begin : pipeline_stage
            always @(posedge clk) begin
                if (reset) begin
                    x_pipe[i] <= 0;
                    y_pipe[i] <= 0;
                    q_pipe[i] <= 0;
                    r_pipe[i] <= 0;
                    valid_pipe[i] <= 0;
                end else begin
                    if (i == 0) begin
                        // 第一级
                        x_pipe[i] <= x;
                        y_pipe[i] <= y;
                        valid_pipe[i] <= start;
                        // 初始化计算...
                    end else begin
                        // 中间级 - 继续除法计算
                        x_pipe[i] <= x_pipe[i-1];
                        y_pipe[i] <= y_pipe[i-1];
                        valid_pipe[i] <= valid_pipe[i-1];
                        // 每级计算1-2位...
                    end
                end
            end
        end
    endgenerate
    
    assign q = q_pipe[PIPELINE_STAGES-1];
    assign r = r_pipe[PIPELINE_STAGES-1];
    assign valid = valid_pipe[PIPELINE_STAGES-1];
    assign busy = |valid_pipe; // 任何一级有效都表示忙
    assign dbz = (y == 0) && start;
    
endmodule
```

### ht_sig_crc_calc_parallel.v - 并行CRC计算
```verilog
module ht_sig_crc_calc_parallel (
    input wire clk,
    input wire reset,
    input wire [33:0] d,
    input wire start,
    output wire busy,
    output wire valid,
    output wire [7:0] crc
);
    
    // 使用查找表方法并行计算CRC8
    // 多项式: x^8 + x^2 + x + 1 (0x107)
    
    reg [7:0] crc_reg;
    reg [2:0] state;
    reg [33:0] data_reg;
    
    // 并行CRC计算逻辑
    always @(posedge clk) begin
        if (reset) begin
            crc_reg <= 8'hFF;
            state <= 0;
            data_reg <= 0;
        end else if (start) begin
            data_reg <= d;
            state <= 1;
            crc_reg <= 8'hFF;
        end else if (state != 0) begin
            case (state)
                1: begin
                    // 第一字节并行计算
                    crc_reg <= crc8_table1[crc_reg ^ data_reg[33:26]];
                    state <= 2;
                end
                2: begin
                    // 第二字节并行计算  
                    crc_reg <= crc8_table2[crc_reg ^ data_reg[25:18]];
                    state <= 3;
                end
                3: begin
                    // 第三字节并行计算
                    crc_reg <= crc8_table3[crc_reg ^ data_reg[17:10]];
                    state <= 4;
                end
                4: begin
                    // 第四字节并行计算（部分）
                    crc_reg <= crc8_table4[crc_reg ^ {data_reg[9:2], 2'b00}];
                    state <= 0;
                end
            endcase
        end
    end
    
    assign busy = (state != 0);
    assign valid = (state == 4); // 下一周期有效
    assign crc = ~crc_reg; // CRC最终取反
    
    // CRC查找表（预计算）
    // 实际实现中需要预计算这些表
    
endmodule
```

## 性能提升预期

### 理论性能分析
- **数据位宽**：64位 → 128位（2倍）
- **FIFO深度**：8K → 16K（减少阻塞）
- **时钟频率**：通过流水线可提升20-30%
- **协议处理**：并行化减少30-50%延迟

### 预期吞吐量
- **原始性能**：~300 Mbps
- **优化后**：800 Mbps - 1.2 Gbps
- **极限性能**：1.5+ Gbps（128位 @ 150MHz）

### 关键优化效果
1. **数据路径**：位宽加倍直接提升2倍吞吐量
2. **状态机**：并行化减少40%处理延迟  
3. **内存访问**：True Dual Port提高并发性
4. **计算单元**：流水线化提升时序性能

这些修改需要综合验证功能正确性和时序收敛性，建议逐步实施并验证每个优化阶段的效果。